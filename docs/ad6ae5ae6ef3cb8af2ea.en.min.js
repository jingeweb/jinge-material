!function(){const e={locale:"en",dictionary:{"cN2y#":"Name","irK?+":"Description",o1PP5:"Default","b7z[W":"Parameters","Tv(Z_":"Usage","w$!H^":"Creates a custom autocomplete result item","XP!Q%":"Will receive each item of the matched options.","LX7.]":"The current input search term.","R$~#r":"Creates a empty state in case of zero matches","7;4YI":"bind the autocomplete value","hf'Ip":"The available options to be searched. If Array, the autocomplete will use a inner search engine. If Promise, you will need to implement the search by yourself (this is commonly made by a backend service).","nT64}":"The input name attribute","UQTY;":"The input id attribute","W(|k5":"Enables a character count, based on the given value.","p#,5!":"Sets a optional placeholder on autocomplete.","kGll*":"Enable the dense layout for options","4Xtg#":"Sets the input layout. The floating variant is the default. See below the detailed description of each layout.","Xg>q1":"Sets the input layout to floating. This is the default.",BFsx:"Sets the input layout to a boxed layout.","7w>|<":"Disable/enable the on focus event. If <code>false</code>, the options will show the results right after a keystroke.","Fbc'H":"If option is object, you need to specify which attribute will be used for the search filter.","K6{Dz":"Disable/enable the fuzzy search algorithm. If <code>false</code>, the search will match the whole search term. This option do not take any effects if the <code>md-options</code> is a Promise","LHbB&":"Triggered when the user types on the input field","StK,)":"Triggered when the user selects an option","xC?#S":"Triggered when the options panel is opened","Lp=u ":"Triggered when the options panel is closed","Wg`@/":"Input text can be used with autocomplete to help users who have limited literacy or who write in a foreign language. For example, autocomplete can suggest input as itâ€™s typed (refreshing suggestions with each keystroke).",cYHJP:"Static Data",F0qX0:"Trigger","C!eyL":"By default the suggestions will appear along with a focus trigger. If you want something less intrusive, you can disable this behaviour by canceling the focus event. If this, the suggestions will appear right after a keystroke:","m}fb,":"Box Layout","B[/i.":"Autocomplete have types two layouts: Default with floating labels and a boxed layout with inline labels. The box layout will apply a boxed layout with a small elevation, that also works really great as search bar inside a toolbar. Gorgeous:","8=]v":"Custom Template","J3'/p":"Autocomplete also accepts a custom template, flexible to accept any HTML element and with an 'empty state' built in. You can also highlight the search term inside the matches, to give a feedback on why that item has been in the results. Awesome:","E+gKt":"Search Algorithms","6}u)(":"Async Options","OOs=`":"Autocomplete"},render:function(e,t,a,o,i,s,n,l,r,h){return{components:{tSSRX:function(t,o,i){return[e(t,"Autocomplete works like "),(()=>{const e=s("code",Object.assign({[o||""]:o?"":null},t[a].compStyle),"md-field");return t[a].rootNodes.push(e),e})(),e(t,". This means that you can pass labels, validation messages, helper texts and even icons:")]},"1tiT[":function(t,o,i){return[e(t,"If you have a small amount of data or if it's static, you can pass the options to "),(()=>{const e=s("code",Object.assign({[o||""]:o?"":null},t[a].compStyle),"md-autocomplete");return t[a].rootNodes.push(e),e})(),e(t," in a simple and intuitive way:")]},"VhA*5":function(t,o,i){return[e(t,"Although the "),(()=>{const e=s("code",Object.assign({[o||""]:o?"":null},t[a].compStyle),"md-highlight");return t[a].rootNodes.push(e),e})(),e(t," component is most used with autocomplete, you can use it anywhere.")]},"q?bkt":function(t,o,i){return[e(t,"Vue Material autocomplete comes with 2 ways of search: "),(()=>{const e=s("a",Object.assign({href:"https://en.wikipedia.org/wiki/Approximate_string_matching",target:"_blank",[o||""]:o?"":null},t[a].compStyle),"Fuzzy search");return t[a].rootNodes.push(e),e})(),e(t," and search by whole term. The fuzzy search tries to match the results by approximation, finding patterns inside the available options. This will help with accidental type errors and improve the results. If you think that this may be confusing, you can disable this. Example:")]},ABoHS:function(t,o,i){return[e(t,"Sometimes the options are inside a database in a remote server. Instead of giving a static data, we can provide a "),(()=>{const e=s("code",Object.assign({[o||""]:o?"":null},t[a].compStyle),"Promise");return t[a].rootNodes.push(e),e})(),e(t," that will resolve with the data from a backend servide, for example. This is great to save Bandwidth on the initial load and to improve the performance. Look at this example:")]}},attributes:{}}}};"undefined"!=typeof jinge?jinge.i18n.__regLoc(e):window.JINGE_I18N_DATA=e}();